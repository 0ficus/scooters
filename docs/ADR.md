# ADR: scooter-rental-service

## 1. Scope / Title

### Title

Название: **Scooter Rental Service**

### Scope

Данный ADR описывает архитектурное решение для сервиса краткосрочной аренды электрических самокатов — **scooter-rental-service**.  
Документ охватывает проектирование и реализацию логики работы с офферами и заказами, включая аренду, тарификацию, кэширование и взаимодействие с микросервисами системы.

В область ADR входят:

- Создание и завершение заказов аренды;
- Формирование и валидация офферов;
- Расчёт стоимости поездки;
- Интеграция с микросервисами: `scooters`, `payments`, `users`, `zone`, `config`;
- Хранение и периодическая очистка заказов.

Из области ADR **исключаются**:

- Клиентские приложения (мобильное и веб);
- Системы аналитики и отчётности;
- Управление пользователями и платежами за пределами аренды.

### Постановка задачи

Задача — разработать backend-сервис **аренды электросамокатов**, обеспечивающий пользователям возможность:

- получать оффер (предложение) для начала аренды самоката,  
- создавать заказ (начинать аренду),  
- завершать заказ (окончание аренды с фиксацией стоимости),  
- просматривать текущий статус и стоимость активной поездки.  

Основная логика взаимодействия с пользователем реализуется внутри **единого микросервиса `scooter-rental-service`**.  
Он обращается к другим микросервисам системы для получения необходимой информации:  

- `scooters` — данные о доступных самокатах и их состоянии,  
- `payments` — проведение и проверка платежей,  
- `users` — информация о клиентах и их тарифах,  
- `zone` — зоны и правила тарификации,  
- `config` — конфигурационные параметры и системные настройки.  

Взаимодействие между сервисами осуществляется через API.  
Для каждого микросервиса предусмотрен собственный уровень надежности и кэширования.  
Критичные микросервисы (`scooters`, `payments`) должны обеспечивать высокую доступность.

## 2. Business Requirements

1. **Обеспечить надёжный и удобный процесс аренды самокатов.**  
   Пользователь должен иметь возможность бронировать, начинать и завершать поездку.

2. **Поддерживать прозрачное ценообразование.**  
   Пользователь должен видеть актуальную стоимость поездки.

3. **Обеспечить устойчивую работу при сбоях микросервисов.**  
   Критичные сервисы (`scooters`, `payments`) должны обрабатываться с retry и идемпотентностью.  
   Некритичные сервисы (`config`, `zone`, `users`) должны использовать кэш или fallback-механику.

4. **Хранить и управлять данными о заказах.**  
   Должна быть возможность настройки периода хранения данных по зонам.

## 3. Functional Requirements

1. Сервис должен предоставлять API для:
   - создания оффера;
   - создания заказа (начала аренды);
   - завершения заказа;
   - получения информации о заказе и текущей стоимости поездки.

2. Система должна контролировать **свежесть оффера**: устаревшие предложения недействительны.

3. Система должна обеспечивать **идемпотентность** всех операций, изменяющих состояние заказов и офферов.

4. Система должна автоматически **удалять заказы старше 1 года**, при этом период хранения настраивается по зонам.

5. Взаимодействие с микросервисами:
   - `users` — при сбое использовать fallback с “жадным прайсингом”;
   - `config` — кэш обновляется каждую минуту;
   - `zone` — использовать LRU-кэш, данные старше 10 минут считать невалидными (настройка конфигом);
   - `scooters`, `payments` — критичные источники, требующие retry.

6. Сервис должен предоставлять ручку с информацией о заказе и текущей стоимости поездки, доступную для клиента.

7. Все изменения данных должны быть логируемыми.

8. **Нагрузочные параметры:**
   - **X = 100 RPS** — число одновременно создаваемых заказов (внешняя нагрузка);
   - **Y = 50** — количество просмотров информации о заказе на один заказ;
   - **Z = 1 КБ** — средний размер записи о заказе в базе данных.

## 4. Non-Functional Requirements

### Reliability

- Критичные микросервисы (`scooters`, `payments`) должны обрабатываться с retry и гарантией идемпотентности.  
- Данные хранятся в БД.

### Scalability

- Архитектура должна поддерживать горизонтальное масштабирование.
- Изменение параметров логики работы через конфиги.

### Maintainability

- Кодовая база должна быть разделена по доменам (офферы, заказы, зоны и т.д.).
- Архитектура должна соответствовать принципам **SOLID** и допускать добавление новых фич без изменения существующей логики.

### Performance

- Система должна выдерживать нагрузку в соответствии с параметрами X,Y,Z.  
- Кэширование используется для снижения обращений к другим микросервисам.

### Storage

- Все данные заказов хранятся максимум 12 месяцев.  
- Очистка выполняется периодически через фоновый процесс, период зависит от зоны.  
- Размер записи о заказе (Z) ≈ 1 КБ.

## 5. Scheme

Для реализации сервиса `scooter-rental-service` был выбран язык Python и фреймворк Fast API.

### Общая схема сервиса

<img src="scooters_scheme.svg" width="1000">

Ссылка для редактирования: [excalidraw.com](https://excalidraw.com/#json=KI-6KCB_q8U4J-kf7DwhS,2Gdqd_rnBOj5B_SE0iHsLw)

Сервисы `Zones`, `Payments`, `Scooters`, `Configs`, `Users` будут запускаться отдельно от основного сервиса и использовать собственные базы данных или внешние системы для хранения информации (архитектура этих сервисов не рассматривается в ADR).

### Схема поддерживаемых ручек для `scooter-rental-service`

Предполагается, что аутентификация уже была проведена вне сервиса и используются доверенные `user_id`.

#### Схема `/offers/create`

- URI `PUT` запроса: `/offers/create?user_id={user_id}`
- Результат: `{"offer_id": "{offer_id}", "price": {price}}`
  - `user_id` - строка
  - `offer_id` - строка
  - `price` - число

#### Схема `/offers/start`

- URI `PUT` запроса: `/orders/start?user_id={user_id}&offer_id={offer_id}`
- Результат: `{"order_id": "{order_id}"}`
  - `user_id` - строка
  - `offer_id` - строка
  - `order_id` - строка

#### Схема `/offers/get`

- URI `GET` запроса: `/orders/get?user_id={user_id}&order_id={order_id}`
- Результат: `{"total_price": {price}}`
  - `user_id` - строка
  - `order_id` - строка
  - `price` - число

#### Схема `/offers/stop`

- URI `PUT` запроса: `/orders/stop?user_id={user_id}&order_id={order_id}`
- Результат: `{"total_price": {price}}`
  - `user_id` - строка
  - `order_id` - строка
  - `price` - число

#### Схема ошибок

- Коды ошибок:
  - `400 Bad Request` - ошибка в запросе
  - `404 Not Found` - соответствующая информация не найдена для пользователя
  - `500 Internal Server Error` - ошибка внутри сервиса
- Результат: `{"error": "{error_message}"}`
  - `error_message` - строка

### Схемы таблиц

#### Схема таблицы `offers`

```sql
CREATE TABLE Offers (
    offer_id AUTO_INCREMENT PRIMARY KEY,
    user_id  INTEGER NOT NULL,
    scooter_id  INTEGER NOT NULL,
    time_offer_creation TIMESTAMP NOT NULL,
    price_per_minute INTEGER NOT NULL,
    price_unlock  INTEGER NOT NULL,
    deposit  INTEGER NOT NULL,
    ttl INTEGER NOT NULL
);
```

#### Схема таблицы `orders`

```sql
CREATE TABLE Orders (
    order_id AUTO_INCREMENT PRIMARY KEY,
    user_id  INTEGER NOT NULL,
    scooter_id  INTEGER NOT NULL,
    time_start TIMESTAMP NOT NULL,
    time_finish TIMESTAMP NOT NULL,
    price_per_minute INTEGER NOT NULL,
    price_unlock  INTEGER NOT NULL,
    deposit  INTEGER NOT NULL,
    ttl INTEGER NOT NULL
);
```

### Взаимодействие с S3

Сохранение заказов в S3 после завершения позволит значительно снизить объём базы дынных с таблицей `orders` и удешевить её. Также добавление S3 решает проблему шардирования таблицы `orders` на несколько хостов (так как с учётов времени хранения заказа в 1 год нужно сохранить около 3 TB данных).

Процесс сохранения заказов в S3:

- Заказы будут перемещаться в S3 в момент завершения заказа, после успешного сохранения в S3 заказ считается завершённым и удаляется из таблицы `orders`.
- Каждый заказ будет сохраняться в отдельный файл по пути `/orders/zone={zone-id}/year={year}/month={month}/day={day}/{order_id}.json`
  - Таким образом в S3 будет создаваться 100 файлов в секунду.
  - Всего в подпапке одного дня будет 8.64 миллиона файлов с суммарным размером около 8.3 GB.
- На стороне S3 для каждой зоны будет включён свой TTL для файлов с заказами

## 6. Alternatives

### Два сервиса для `offers` и `orders`

Есть два альтернативных варианта для реализации логики `offers` и `orders`:

1. Использование одного микросервиса и одной БД для ручек `/offers/...` и `/orders/...`
2. Использование двух разных микросервисов и БД для ручек `/offers/...` и `/orders/...`

Плюсы и минусы первого подхода относительно второго:

- `+` Упрощается процесс деплоя и контроля совместимости для сервиса
- `+` Есть возможность делать транзакционные изменения одновременно с таблицами `offers` и `orders`
- `+` Более простая система мониторинга в случае использования одного общего сервиса
- `-` Обработка `offers` и `orders` становится зависима, если ломается функциональность только оферов или только заказов - сервис будет полностью недоступен (в случае двух сервисов будет доступен только один микро сервис и, например, нельзя будет создать офер, но можно будет завершить заказ)
- `-` Нету возможности обновить отдельно только код для сервиса `offers` или `orders`
- `-` Есть вероятность, что сервисы `offers` и `orders` будут создавать разные профили нагрузки на базу данных, что может привести к её дестабилизации

Был выбран **первый подход, с одним сервисом**, так как по рассчётам нагрузки было принято решение, что нагрузка на базу будет не слишком различаться между `offers` и `orders`, а также использование одного сервиса значительно упростит процесс деплоя сервиса, мониторинг только одного сервиса потенциально должен быть проще.

### Хранение всех заказов в таблице `orders` без S3

Рассматривалось два альтернативных варианта для выполнения функционального требования по хранения информации о заказах (в среднем 1 KB) в течение года, в зависимости от зоны:

1. После завершения переносить заказы из таблицы `orders` в S3, в папку с соответствующим TTL
2. Хранить все заказы в таблице `orders` без S3 и настраивать TTL для каждой строки в отдельной колонке

Плюсы и минусы первого подхода относительно второго:

- `+` Хранение большого объёма данных в S3 (около 3 TB) значительно дешевле, чем в базе данных
- `+` Нету необходимости шардировать таблицу `orders`, так как её активный размер будет не слишком большим
- `-` Требуется ручная или автоматическая настройка TTL для зон внутри S3
- `-` Нету возможности делать индексы по заказам в S3, что может сказаться на времени поиска исторического заказа

Был **выбран второй подход, с хранением в S3**, так как в случае нехватки каких-либо индексов в S3, можно изменить формат хранения данных, чтобы файловая структура давала достаточную эффективность для бизнес задачи. Так же было решено, что проблема с шардированием таблицы `orders` более значимая, чем настройка TTL для файлов на стороне S3.

## 7. Data estimates

### Функциональные требования по нагрузке

Основные функциональные требования:

- RPS для ручки `/offers/create` равен 100.
- Среднее число просмотров одного заказа пользователем равно 50.
- Размер записи о заказе в базе данных составляет 1 KB.
- Информацию о заказе нужно хранить до одного года.

Дополнительные функциональные требования:

- Офер считается валидным ещё 5 минут после создания.
- Средняя продолжительность заказа - 2 часа.

### Характеристики нагрузки для ручек

#### `/offers/create`

- Ожидаемый RPS: 100 (функциональное требование)
- Ожидаемый latency до 200ms, включает в себя:
  - Проверку доступности самоката и получение его зоны ~ 100 ms
  - Получение конфигурации и информации о зоне ~ 10 ms
  - Получение информации о пользователе ~ 20 ms
  - Сохранение информации об офере в базе данных ~ 70 ms
- Ожидаемое число inflight запросов - 20 (RPS * latency в секундах)

#### `/orders/start`

- Ожидаемый RPS: 100 (предполагаем, что все оферы переходят в создание заказа)
- Ожидаемый latency до 1s, включает в себя:
  - Получение информации об офере ~ 20 ms
  - Получение информации о зоне ~ 10 ms
  - Проверка доступности платёжной системы (списание тестового платежа) ~ 400 ms
  - Сохранение информации о заказе в базе данных и удаление офера ~ 70 ms
  - Разблокировка самоката ~ 500 ms
- Ожидаемое число inflight запросов - 100 (RPS * latency в секундах)

#### `/orders/get`

- Ожидаемый RPS: 5'000 (функциональное требование, RPS создания заказов * число просмотров одного заказа)
- Ожидаемый latency до 20 ms, включает в себя:
  - Получение информации о заказе ~ 20 ms
- Ожидаемое число inflight запросов - 100 (RPS * latency в секундах)

#### `/orders/stop`

- Ожидаемый RPS: 100 (предполагаем, что все заказы завершаются)
- Ожидаемый latency до 1s, включает в себя:
  - Получение информации о заказе ~ 20 ms
  - Списание платежа ~ 400 ms
  - Блокировка самоката ~ 500 ms
  - Выгрузка информации о заказе в S3 ~ 100 ms
  - Удаление заказа из базы данных ~ 70 ms
- Ожидаемое число inflight запросов - 100 (RPS * latency в секундах)

#### Необходимые ресурсы для запуска сервиса

Из расчётов выше для отдельных ручек, характеристики кластера для запуска сервиса `scooter-rental-service`:

- Всего 45 хостов, по 15 хостов в каждой зоне доступности (дата центре)
- Таким образом при отключении одного DC:
  - На каждый из оставшихся 30-ти хостов будет приходиться в районе 180 RPS (суммарный RPS это 5300)
- Деплой новой версии будет проводиться через последовательную выкатку в каждый DC по одному

Характеристики каждого хоста:

- 11 CPU из расчёта:
  - Будем считать, что каждая ручка требует ~100 элементарных операций на обработку (задача в основном IO intensive)
  - Python может обрабатывать до 1 млн операций в секунду
  - Каждый MB / s обработанного трафика с базой данных так же будет стоить 1 CPU
  - Исходя из суммарного RPS до 5300 и суммарного трафика с БД на чтение / запись до 5.4 MB / s потребуется хотя бы 11 CPU
- 1 GB оперативной памяти из расчёта:
  - Суммарный inflight запросов будет до 320, на каждый запрос будем держать в памяти информацию о заказе (1 KB) и метаинформацию по запросу (оценим в 1 KB), получается 0.62 MB памяти
  - Оценим память на прочие активности HTTP сервера на Fast API в 1 GB

### Характеристики нагрузки на базу данных

#### Таблица `offers`

- Ожидаемое число одновременно хранимых строк: 30k (равно времени валидности офера * RPS создания офера)
- Если считать, что размер записи об офере не превышает размера записи одного заказа (1 KB), то одновременно будет храниться 30 MB данных
- Скорость записи в таблицу можно оценить как 100 KB / s
- Скорость чтения из таблицы можно оценить как 100 KB / s (в среднем офер читается один раз при создании заказа)
- Ожидаемый RPS запросов использующих таблицу - 100 (RPS создания офера)
- Ожидаемое количество inflight запросов - 120 (не превышает inflight для создания офера + создания заказа)

#### Таблица `orders`

Оценка затрат на хранение активных `orders` в таблице:

- Ожидаемое число одновременно хранимых строк: 720k (равно среднему времени заказа * RPS создания заказа)
- Одновременно будет храниться 720 MB данных
- Скорость записи можно оценить как 100 KB / s
- Скорость чтения можно оценить как 5.1 MB / s (равно суммарному RPS на просмотр информации о заказе и завершении заказа * размер информации о заказе)
- Ожидаемый RPS запросов использующих таблицу - 5200 (RPS создания заказа + RPS просмотра информации о заказе + RPS завершения заказа)
- Ожидаемое количество inflight запросов - 300 (не превышает inflight для создания заказа + просмотра заказа + завершения заказа)

Оценка затрат на хранение завершённых `orders` в S3:

- Ожидаемое число одновременно хранимых строк: 3'153.6kk (равно времени хранения заказа * RPS создания заказа)
- Одновременно будет храниться 3 TB данных
- Скорость записи можно оценить как 100 KB / s

#### Характеристики кластера БД в целом

Из расчётов выше для отдельных таблиц, характеристики кластера БД:

- 30 хостов, по 10 хостов в трёх разных зонах доступности (дата центрах)
- Будет использоваться конфигурация с одним мастером и 29 репликами:
  - Для ручек `/orders/start` и `/orders/stop` будет использоваться 3 синхронных реплики (по одной в каждом DC)
  - Для ручки `/orders/get` будут использоваться 26 асинхронных реплик, распределённых по DC (для этой ручки не так важна свежесть данных)
- Оценка нагрузки на хосты БД в случае отключения одного DC:
  - Нагрузка на мастер не изменится - 300 RPS на запись / обновление в таблице
  - Нагрузка на две синхронные реплики от `/orders/start` и `/orders/stop` будет по 100 RPS на каждую
  - Нагрузка на 17 асинхронных реплик от `/orders/get` будет в пределах 300 RPS на каждую
- Можно проводить обновление базы последовательно выкатывая её на отдельные дата центры

Характеристики каждого хоста:

- 10 GB дискового пространства, так как:
  - Нужно хранить хотя бы 750 MB данных хранить одновременно
- Пропускная способность диска на запись должна быть хотя бы 2 MB / s, так как:
  - Суммарная скорость записи в таблицы не менее чем 200 KB / s
- Пропускная способность диска на чтение должна быть хотя бы 52 MB / s, так как:
  - Суммарная скорость чтения из таблиц не менее чем 5.2 MB / s
- 20 CPU, так как:
  - Будем считать, что в PostgreSQL требуется хотя бы 1 CPU на каждые 10 MB / s потока данных для чтения и записи
  - И что, с учётом кеширования компиляции запросов, требуется хотя бы 1 CPU на обработку 1млн RPS запросов затрагивающих одну сроку (операции не связанные с прямой обработкой данных)
  - Суммарный PRS для базы будет до 5300, что требует не менее одного CPU
  - Суммарная скорость чтения и записи будет хотя не более чем 5.4 MB / s, что требует не менее одного CPU
- 10 GB оперативной памяти, так как:
  - Оценим дополнительное потребление памяти на 1 inflight запрос, как размер строки в базе (1 KB) + дополнительные расходы в PG на один запрос как 1 KB, при суммарном inflight до 430 выходит будет нужно не менее чем 0.86 MB памяти
  - Оценим в 1 GB расходы на дополнительные активности базы данных (например кеши)

## 8. Degradations

### Недоступность внешних сервисов

#### Недоступность сервиса `Scooters`

Сервис является Tir-A, его недостпуность приведёт к немедленной недоступности ручек создания офера, старта и завершения заказа (`/offers/create`, `/orders/start` и `/orders/stop`).

#### Недоступность сервиса `Payment`

Сервис является Tir-A, его недостпуность приведёт к немедленной недоступности ручек старта и завершения заказа (`/orders/start` и `/orders/stop`).

#### Недоступность сервиса `Configs`

Данные сервиса `Configs` кешируются, кеш обновляется каждую минуту, в случае недоступности сервиса:

- Импакт на пользователей: на время недоступности будет отставание в применении настроек прайсинга для создания офера

#### Недоступность сервиса `Zone`

Данные для сервиса `Zone` кешируются с таймаутом в 10 минут (настраивается в конфиге), таким образом:

- В первые 10 минут недоступности сервиса будут использоваться данные из кеша
  - Импакт на пользователей: возможно небольшое отставание в определении прайсинга зоны
  - Прочее: будет отставание при изменении настроек TTL для зоны
- Далее в случае продолжительных неполадок все запросы, требующие взаимодействия с сервисом `Zone`, будут обрабатываться с ошибкой
  - Импакт на пользователей: полностью недоступны ручки для создания офера и заказа (`/offers/create` и `/orders/start`)

#### Недоступность сервиса `Users`

В случае недоступности сервиса `Users`:

- Импакт на пользователей: для премиальных пользователей или пользователей с подпиской будет применяться обычный "жадный" прайсинг при создании офера

### Недоступность внешних систем

#### Недоступность базы данных с таблицами `offers` и `orders`

В случае недоступности одного дата центра для базы данных, нагрузка будет перераспределена на два других DC, система продолжит работать в штатном режиме (из рассчёта, что ресурсов в двух DC достаточно).

В случае полной недоступности всех реплик базы данных, для пользователей перестанут работать все ручки сервиса `scooter-rental-service` (`/offers/create`, `/orders/start`, `/orders/get` и `/orders/stop`).

#### Недоступность базы Redis с cache дял `Zone`

В этом случае возрастёт нагрузка на сервис `Zone` и его функционирование в этот период будет критичным для работы ручек `/offers/create` и `/orders/start`.

#### Хранилища S3

На время недоступности S3 пользователь не сможет успешно завершить свой заказ, будет недоступна ручка `/orders/stop`.
