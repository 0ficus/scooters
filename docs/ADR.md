# ADR: scooter-rental-service  

## 1. Скоуп / Название

### Название

Название: **Scooter Rental Service**

### Скоуп

Данный ADR описывает архитектурное решение для сервиса краткосрочной аренды электрических самокатов — **scooter-rental-service**.  
Документ охватывает проектирование и реализацию логики работы с офферами и заказами, включая аренду, тарификацию, кэширование и взаимодействие с микросервисами системы.

В область ADR входят:

- Создание и завершение заказов аренды;
- Формирование и валидация офферов;
- Расчёт стоимости поездки;
- Интеграция с микросервисами: `scooters`, `payments`, `users`, `zone`, `config`;
- Хранение и периодическая очистка заказов.

Из области ADR **исключаются**:

- Клиентские приложения (мобильное и веб);
- Системы аналитики и отчётности;
- Управление пользователями и платежами за пределами аренды.

### Постановка задачи

Задача — разработать backend-сервис **аренды электросамокатов**, обеспечивающий пользователям возможность:

- получать оффер (предложение) для начала аренды самоката,  
- создавать заказ (начинать аренду),  
- завершать заказ (окончание аренды с фиксацией стоимости),  
- просматривать текущий статус и стоимость активной поездки.  

Основная логика взаимодействия с пользователем реализуется внутри **единого микросервиса `scooter-rental-service`**.  
Он обращается к другим микросервисам системы для получения необходимой информации:  

- `scooters` — данные о доступных самокатах и их состоянии,  
- `payments` — проведение и проверка платежей,  
- `users` — информация о клиентах и их тарифах,  
- `zone` — зоны и правила тарификации,  
- `config` — конфигурационные параметры и системные настройки.  

Взаимодействие между сервисами осуществляется через API.  
Для каждого микросервиса предусмотрен собственный уровень надежности и кэширования.  
Критичные микросервисы (`scooters`, `payments`) должны обеспечивать высокую доступность.

## 2. Бизнес требования

1. **Обеспечить надёжный и удобный процесс аренды самокатов.**  
   Пользователь должен иметь возможность бронировать, начинать и завершать поездку.

2. **Поддерживать прозрачное ценообразование.**  
   Пользователь должен видеть актуальную стоимость поездки.

3. **Обеспечить устойчивую работу при сбоях микросервисов.**  
   Критичные сервисы (`scooters`, `payments`) должны обрабатываться с retry и идемпотентностью.  
   Некритичные сервисы (`config`, `zone`, `users`) должны использовать кэш или fallback-механику.

4. **Хранить и управлять данными о заказах.**  
   Должна быть возможность настройки периода хранения данных по зонам.

## 3. Функциональные требования

1. Сервис должен предоставлять API для:
   - создания оффера;
   - создания заказа (начала аренды);
   - завершения заказа;
   - получения информации о заказе и текущей стоимости поездки.

2. Система должна контролировать **свежесть оффера**: устаревшие предложения недействительны.

3. Система должна обеспечивать **идемпотентность** всех операций, изменяющих состояние заказов и офферов.

4. Система должна автоматически **удалять заказы старше 1 года**, при этом период хранения настраивается по зонам.

5. Взаимодействие с микросервисами:
   - `users` — при сбое использовать fallback с “жадным прайсингом”;
   - `config` — кэш обновляется каждую минуту;
   - `zone` — использовать LRU-кэш, данные старше 10 минут считать невалидными (настройка конфигом);
   - `scooters`, `payments` — критичные источники, требующие retry.

6. Сервис должен предоставлять ручку с информацией о заказе и текущей стоимости поездки, доступную для клиента.

7. Все изменения данных должны быть логируемыми.

8. **Нагрузочные параметры:**
   - **X = 100 RPS** — число одновременно создаваемых заказов (внешняя нагрузка);
   - **Y = 50** — количество просмотров информации о заказе на один заказ;
   - **Z = 1 КБ** — средний размер записи о заказе в базе данных.

## 4. Не функциональные требования

### Reliability

- Критичные микросервисы (`scooters`, `payments`) должны обрабатываться с retry и гарантией идемпотентности.  
- Данные хранятся в БД.

### Scalability

- Архитектура должна поддерживать горизонтальное масштабирование.
- Изменение параметров логики работы через конфиги.

### Maintainability

- Кодовая база должна быть разделена по доменам (офферы, заказы, зоны и т.д.).
- Архитектура должна соответствовать принципам **SOLID** и допускать добавление новых фич без изменения существующей логики.

### Performance

- Система должна выдерживать нагрузку в соответствии с параметрами X,Y,Z.  
- Кэширование используется для снижения обращений к другим микросервисам.

### Storage

- Все данные заказов хранятся максимум 12 месяцев.  
- Очистка выполняется периодически через фоновый процесс, период зависит от зоны.  
- Размер записи о заказе (Z) ≈ 1 КБ.

## Scheme

<img src="Scooters_Scheme.svg" width="1000">

## 5. Оценки данных

### Функциональные требования по нагрузке

Основные функциональные требования:

- RPS для ручки `/offers/create` равен 100.
- Среднее число просмотров одного заказа пользователем равно 50.
- Размер записи о заказе в базе данных составляет 1 KB.
- Информацию о заказе нужно хранить до одного года.

Дополнительные функциональные требования:

- Офер считается валидным ещё 5 минут после создания.
- Средняя продолжительность заказа - 2 часа.

### Характеристики нагрузки для ручек

#### `/offers/create`

- Ожидаемый RPS: 100 (функциональное требование)
- Ожидаемый latency до 200ms, включает в себя:
  - Проверку доступности самоката и получение его зоны ~ 100 ms
  - Получение конфигурации и информации о зоне ~ 10 ms
  - Получение информации о пользователе ~ 20 ms
  - Сохранение информации об офере в базе данных ~ 70 ms

#### `/orders/start`

- Ожидаемый RPS: 100 (предполагаем, что все оферы переходят в создание заказа)
- Ожидаемый latency до 1s, включает в себя:
  - Получение информации об офере ~ 20 ms
  - Получение информации о зоне ~ 10 ms
  - Проверка доступности платёжной системы (списание тестового платежа) ~ 400 ms
  - Сохранение информации о заказе в базе данных и удаление офера ~ 70 ms
  - Разблокировка самоката ~ 500 ms

#### `/orders/get`

- Ожидаемый RPS: 5'000 (функциональное требование, RPS создания заказов * число просмотров одного заказа)
- Ожидаемый latency до 20 ms, включает в себя:
  - Получение информации о заказе ~ 20 ms

#### `/orders/stop`

- Ожидаемый RPS: 100 (предполагаем, что все заказы завершаются)
- Ожидаемый latency до 1s, включает в себя:
  - Получение информации о заказе ~ 20 ms
  - Списание платежа ~ 400 ms
  - Блокировка самоката ~ 500 ms
  - Выгрузка информации о заказе в S3 ~ 100 ms
  - Удаление заказа из базы данных ~ 70 ms

### Характеристики нагрузки на базу данных

#### Таблица `offers`

- Ожидаемое число одновременно хранимых строк: 30k (равно времени валидности офера * RPS создания офера)
- Если считать, что размер записи об офере не превышает размера записи одного заказа (1 KB), то одновременно будет храниться 30 MB данных
- Скорость записи в таблицу можно оценить как 100 KB / s
- Скорость чтения из таблицы можно оценить как 100 KB / s (в среднем офер читается один раз при создании заказа)

#### Таблица `orders`

Оценка затрат на хранение активных `orders` в таблице:

- Ожидаемое число одновременно хранимых строк: 720k (равно среднему времени заказа * RPS создания заказа)
- Одновременно будет храниться 720 MB данных
- Скорость записи можно оценить как 100 KB / s
- Скорость чтения можно оценить как 5.1 MB / s (равно суммарному RPS на просмотр информации о заказе и завершении заказа * размер информации о заказе)

Оценка затрат на хранение завершённых `orders` в S3:

- Ожидаемое число одновременно хранимых строк: 3'153.6kk (равно времени хранения заказа * RPS создания заказа)
- Одновременно будет храниться 3 TB данных
- Скорость записи можно оценить как 100 KB / s
