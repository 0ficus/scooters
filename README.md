# ADR: scooter-rental-service  

## 1. Scope / Title

### Title
**Scooter Rental Service**

### Scope
Данный ADR описывает архитектурное решение для сервиса краткосрочной аренды электрических самокатов — **scooter-rental-service**.  
Документ охватывает проектирование и реализацию логики работы с офферами и заказами, включая аренду, тарификацию, кэширование и взаимодействие с микросервисами системы.

В область ADR входят:
- Создание и завершение заказов аренды;
- Формирование и валидация офферов;
- Расчёт стоимости поездки;
- Интеграция с микросервисами: `scooters`, `payments`, `users`, `zone`, `config`;
- Хранение и периодическая очистка заказов.

Из области ADR **исключаются**:
- Клиентские приложения (мобильное и веб);
- Системы аналитики и отчётности;
- Управление пользователями и платежами за пределами аренды.

---

### Постановка задачи

Задача — разработать backend-сервис **аренды электросамокатов**, обеспечивающий пользователям возможность:  
- получать оффер (предложение) для начала аренды самоката,  
- создавать заказ (начинать аренду),  
- завершать заказ (окончание аренды с фиксацией стоимости),  
- просматривать текущий статус и стоимость активной поездки.  

Основная логика взаимодействия с пользователем реализуется внутри **единого микросервиса `scooter-rental-service`**.  
Он обращается к другим микросервисам системы для получения необходимой информации:  

- `scooters` — данные о доступных самокатах и их состоянии,  
- `payments` — проведение и проверка платежей,  
- `users` — информация о клиентах и их тарифах,  
- `zone` — зоны и правила тарификации,  
- `config` — конфигурационные параметры и системные настройки.  

Взаимодействие между сервисами осуществляется через API.  
Для каждого микросервиса предусмотрен собственный уровень надежности и кэширования.  
Критичные микросервисы (`scooters`, `payments`) должны обеспечивать высокую доступность.

---

## 3. Business Requirements

1. **Обеспечить надёжный и удобный процесс аренды самокатов.**  
   Пользователь должен иметь возможность бронировать, начинать и завершать поездку.

2. **Поддерживать прозрачное ценообразование.**  
   Пользователь должен видеть актуальную стоимость поездки.

3. **Обеспечить устойчивую работу при сбоях микросервисов.**  
   Критичные сервисы (`scooters`, `payments`) должны обрабатываться с retry и идемпотентностью.  
   Некритичные сервисы (`config`, `zone`, `users`) должны использовать кэш или fallback-механику.

4. **Хранить и управлять данными о заказах.**  
   Должна быть возможность настройки периода хранения данных по зонам.

---

## 4. Functional Requirements

1. Сервис должен предоставлять API для:
   - создания оффера;
   - создания заказа (начала аренды);
   - завершения заказа;
   - получения информации о заказе и текущей стоимости поездки.

2. Система должна контролировать **свежесть оффера**: устаревшие предложения недействительны.

3. Система должна обеспечивать **идемпотентность** всех операций, изменяющих состояние заказов и офферов.

4. Система должна автоматически **удалять заказы старше 1 года**, при этом период хранения настраивается по зонам.

5. Взаимодействие с микросервисами:
   - `users` — при сбое использовать fallback с “жадным прайсингом”;
   - `config` — кэш обновляется каждую минуту;
   - `zone` — использовать LRU-кэш, данные старше 10 минут считать невалидными (настройка конфигом);
   - `scooters`, `payments` — критичные источники, требующие retry.

6. Сервис должен предоставлять ручку с информацией о заказе и текущей стоимости поездки, доступную для клиента.

7. Все изменения данных должны быть логируемыми.

8. **Нагрузочные параметры:**
   - **X = 100 RPS** — число одновременно создаваемых заказов (внешняя нагрузка);
   - **Y = 50** — количество просмотров информации о заказе на один заказ;
   - **Z = 1 КБ** — средний размер записи о заказе в базе данных.

---

## 5. Non-Functional Requirements

### Reliability
- Критичные микросервисы (`scooters`, `payments`) должны обрабатываться с retry и гарантией идемпотентности.  
- Данные хранятся в БД.

### Scalability
- Архитектура должна поддерживать горизонтальное масштабирование.
- Изменение параметров логики работы через конфиги.

### Maintainability
- Кодовая база должна быть разделена по доменам (офферы, заказы, зоны и т.д.).
- Архитектура должна соответствовать принципам **SOLID** и допускать добавление новых фич без изменения существующей логики.

### Performance
- Система должна выдерживать нагрузку в соответствии с параметрами X,Y,Z.  
- Кэширование используется для снижения обращений к другим микросервисам.

### Storage
- Все данные заказов хранятся максимум 12 месяцев.  
- Очистка выполняется периодически через фоновый процесс, период зависит от зоны.  
- Размер записи о заказе (Z) ≈ 1 КБ.
